---
layout: post
comments: true
title: "A 100% test coverage should be a goal for every project"
date: 2016-03-18 11:47:00 -0430
categories: test coverage
---
Maybe I'm talking about my limited experience on small and medium size projects
(although I've been programming for over 10 years I've never been in a large codebase), I think a 100% test coverage
should be a goal for every project. Now, I don't mean the whole project should be covered, but the code you manually
type; that will exclude the logs, temps, autogenerated code, even config files.

As every tool developers use you should be able to configure your coverage tool so you can include only the
pieces you need to test. Of course, this metric is not the only one we can use to make sure our code is safely tested,
but I think is a good one.

I've been reading a few posts negating the efficiency of [TDD](https://en.wikipedia.org/wiki/Test-driven_development),
like [Dubious Decisions: Passing on TDD](http://www.thecaucus.net/#/content/caucus/tech_blog/432) and
[Giving up on test-first development](http://iansommerville.com/systems-software-and-technology/giving-up-on-test-first-development/).
I can't agree more on that. I'm not sure if this has been stated before (as a methodology), but what I do is the next:

- Write code.
- Write test.
- Check code coverage.

So, if I don't feel satisfied with the coverage percentage, I write more tests accordingly.

However using only test coverage is not enough, there are some flaws that I will show, I'll be using Ocaml as an example. 
First, lets say we want to write a function that sums two numbers, we can write it this way:

`mymodule.ml`
{% highlight ocaml %}
let sum_two_numbers first second = first + second
{% endhighlight %}

Simple, right?, now we're going to create the unit test using [OUnit](http://ounit.forge.ocamlcore.org/):

`test.ml`
{% highlight ocaml %}
open OUnit2;;

let test1 sum_two_numbers_test = assert_equal 121 (Mymodule.sum_two_numbers 54 67);;

let suite =
"suite">:::
  ["test1">:: test1]
;;

let () =
  run_test_tt_main suite
;;
{% endhighlight %}

We need a coverage tool and looks like bisect is the most popular one, so we'll be using that, for this example
we'll be using [bisect_ppx](https://github.com/rleonid/bisect_ppx). So, we just need to type in the command line the next:

{% highlight bash %}
ocamlfind c -package bisect_ppx -c mymodule.ml
ocamlfind c -c test.ml
ocamlfind c -linkpkg -package bisect_ppx -package oUnit mymodule.cmo test.cmo
./a.out
bisect-ppx-report -I build/ -html coverage/ bisect*.out
{% endhighlight %}

Now, you can open coverage/index.html, and see a shiny coverage report for our code.
![Coverage Report]({{ site.url }}/assets/coverage.png)

So, we decided our module is ready to use and test it in a repl, we open utop and type:

{% highlight ocaml %}
{% endhighlight %}
